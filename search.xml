<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>python中的装饰器</title>
    <url>/2022/05/05/Decorator-In-Python/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="? 前言"></a>? 前言</h2><p>Python中的一切皆对象。同样函数也是如此。</p>
<p>装饰器（形如@staticmethod, @overload等）其实是一个<code>装饰器函数或一个装饰器类</code>对<code>装饰器装饰的函数</code>的<code>对象</code>的调用再赋值的过程, 表面上体现为以函数对象作为参数。</p>
<h3 id="实质"><a href="#实质" class="headerlink" title="? 实质"></a>? 实质</h3><blockquote>
<p>@decorator</p>
<p>function_name()</p>
<p>等价于：</p>
<p>function_name &#x3D; decorator(function_name)</p>
<p>（其中，有这么一个装饰器函数：</p>
<p>def decorator(f):</p>
<p>​		@wraps(f)</p>
<p>​		def xxx(xx, xx…):</p>
<p>​				… # 调用前</p>
<p>​				return f()  # 或者直接f()来调用函数</p>
<p>​				…  # 调用后</p>
<p>​		return xxx</p>
</blockquote>
<h2 id="普通装饰器"><a href="#普通装饰器" class="headerlink" title="? 普通装饰器"></a>? 普通装饰器</h2><p>(直接拿菜鸟教程的例子)</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a_new_decorator</span>(<span class="params">a_func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrap_the_function</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;I am doing some boring work before executing a_func()&quot;</span>)</span><br><span class="line">        a_func()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;I am doing some boring work after executing a_func()&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> warp_the_function</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">a_function_requiring_decoration</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I am the function which needs some decoration to remove my foul smell&quot;</span>)</span><br><span class="line">   </span><br><span class="line">a_function_requiring_decoration()</span><br><span class="line"><span class="comment"># outputs: &quot;I am the function which needs some decoration to remove my foul smell&quot;</span></span><br><span class="line">a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration)</span><br><span class="line"><span class="comment">#now a_function_requiring_decoration is wrapped by wrap_the_function()</span></span><br><span class="line"></span><br><span class="line">a_function_requiring_decration()</span><br><span class="line"><span class="comment">#outputs:I am doing some boring work before executing a_func()</span></span><br><span class="line"><span class="comment">#        I am the function which needs some decoration to remove my foul smell</span></span><br><span class="line"><span class="comment">#        I am doing some boring work after executing a_func()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li><p>用装饰器写</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@a_new_decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">a_function_requring_decoration</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I am a function which needs some decoration to&quot;</span></span><br><span class="line">          <span class="string">&quot;remove my foul smell&quot;</span>)</span><br><span class="line">    </span><br><span class="line">a_function_requiring_decoration()</span><br><span class="line"><span class="comment"># outputs: I am doing some boring work before executing a_func()</span></span><br><span class="line"><span class="comment">#         I am the function which needs some decoration to remove my foul smell</span></span><br><span class="line"><span class="comment">#         I am doing some boring work after executing a_func()</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#the @a_new_decorator is just a short way of saying:</span></span><br><span class="line">a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration)</span><br></pre></td></tr></table></figure>



<ul>
<li><p>特殊点：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(a_function_requiring_decoration.__name__)</span><br><span class="line"><span class="comment"># Output: wrap_the_function</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>并没有输出”a_function_requiring_decoration”。而被”wrap_the_function”替代了。</p>
</blockquote>
<ul>
<li><p>解决方案</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">a_new_decorator</span>(<span class="params">a_func</span>):</span><br><span class="line"><span class="meta">    @wrap(<span class="params">a_func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrap_the_function</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;I am doing some boring work before execting a_func&quot;</span>)</span><br><span class="line">        a_func()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;I am doing some boring work after exexting a_func()&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> wrap_the_function</span><br><span class="line"><span class="meta">@a_new_decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">a_function_requring_decoration</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I am the function which needs some decoration to &quot;</span></span><br><span class="line">          <span class="string">&quot;remove my foul smell&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(a_function_requiring_decoration.__name__)</span><br><span class="line"><span class="comment"># Output: a_function_requiring_decoration</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="？带参数的装饰器"><a href="#？带参数的装饰器" class="headerlink" title="？带参数的装饰器"></a>？带参数的装饰器</h2><ul>
<li>思路： 创建一个包裹函数。在装饰器函数外面包一层。<ul>
<li>例：</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">logit</span>(<span class="params">logfile=<span class="string">&quot;out.log&quot;</span></span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">logging_decrator</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">        @wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapped_function</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            log_string = func.__name__ + <span class="string">&quot;was called&quot;</span></span><br><span class="line">            <span class="built_in">print</span>(log_string)</span><br><span class="line">            <span class="comment"># 打开lgofile，并写入内容</span></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(logfile, <span class="string">&quot;a&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(log_string + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kargs)</span><br><span class="line">        <span class="keyword">return</span> wrapped_function</span><br><span class="line">    <span class="keyword">return</span> logging_decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@logit()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">myfunc1</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line">myfunc1()</span><br><span class="line"><span class="comment"># Output: myfunc1 was called</span></span><br><span class="line"><span class="comment"># 现在一个叫做 out.log 的文件出现了，里面的内容就是上面的字符串</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">@logit(<span class="params">logfile=<span class="string">&#x27;func2.log&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">myfunc2</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line">myfunc2()</span><br><span class="line"><span class="comment"># Output: myfunc2 was called</span></span><br><span class="line"><span class="comment"># 现在一个叫做 func2.log 的文件出现了，里面的内容就是上面的字符串</span></span><br></pre></td></tr></table></figure>

<h2 id="？应用场景"><a href="#？应用场景" class="headerlink" title="？应用场景"></a>？应用场景</h2><blockquote>
<p>授权</p>
</blockquote>
<blockquote>
<p>日志</p>
</blockquote>
<h2 id="？装饰器类"><a href="#？装饰器类" class="headerlink" title="？装饰器类"></a>？装饰器类</h2><ul>
<li>当你想利用装饰器执行不止一个操作时，可以用来类来包装。</li>
</ul>
<p>例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logit</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, logfile=<span class="string">&#x27;out.log&#x27;</span></span>):</span><br><span class="line">        self.logfile = logfile</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, func</span>):</span><br><span class="line"><span class="meta">        @wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapped_function</span>(<span class="params">*args, **kargs</span>):</span><br><span class="line">            log_string = func.__name__ + <span class="string">&quot;was called&quot;</span></span><br><span class="line">            <span class="built_in">print</span>(log_string)</span><br><span class="line">            <span class="comment"># 打开logfile并写入</span></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(self.logfile, <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(log_string + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            <span class="comment"># 现在，发送一个通知</span></span><br><span class="line">            self.notify()</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kargs)</span><br><span class="line">        <span class="keyword">return</span> wrapped_function</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">notify</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 该类为logit类，什么也不做，交个子类</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmailLogit</span>(<span class="title class_ inherited__">Logit</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Logit子类,实现日志记录的同时发邮件</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, email=<span class="string">&quot;admin@myproject.com&quot;</span>, *args, **kargs</span>):</span><br><span class="line">        self.email = email</span><br><span class="line">        <span class="built_in">super</span>(EmailLogit, self).__init__(*args, **kargs)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">notify</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 具体实现</span></span><br><span class="line">        ...</span><br><span class="line">       </span><br><span class="line"><span class="comment"># 调用时与装饰器函数类似。使用@Logit</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Generator-In-Python</title>
    <url>/2022/07/06/Generator-In-Python/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="? 前言"></a>? 前言</h2><p><code>yield</code>是Python极其重要的一个关键字，它与Python中的<code>生成器</code>密切相关，并且它的用法时不时让人困惑…</p>
<h2 id="yield有什么用"><a href="#yield有什么用" class="headerlink" title="? yield有什么用"></a>? <code>yield</code>有什么用</h2><ul>
<li><p>大多数情况下，使用<code>yield</code>都是为了将函数作为生成器使用。(<code>yield</code>只能在函数中使用)</p>
</li>
<li><p>当有大量数据需要返回时这能够节省内存空间。</p>
</li>
</ul>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="? 生成器"></a>? 生成器</h2><p><strong>正常思路的斐波那契:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fab</span>(<span class="params"><span class="built_in">max</span></span>):</span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    L = [] <span class="comment"># 拿一个列表来存数据，提高复用性</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="built_in">max</span>:</span><br><span class="line">        L.append(b)</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> fab(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(n)</span><br></pre></td></tr></table></figure>

<p>这么做会使该函数的内存占用随参数<code>max</code>增大而增加。</p>
<blockquote>
<p>引言：</p>
<p>​        生成器：实质是一个拥有<code>__next__()</code>方法和       <code>__iter__()</code>方法的类。拥有一边循环一边计算的机制</p>
</blockquote>
<p><strong>生成器类构建的斐波那契:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fab</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, <span class="built_in">max</span></span>):</span><br><span class="line">        self.<span class="built_in">max</span> = <span class="built_in">max</span></span><br><span class="line">        self.n, self.a, self.b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">next</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.n &lt; self.<span class="built_in">max</span>:</span><br><span class="line">            r = self.b</span><br><span class="line">            self.a, self.b = self.b, self.a + self.b</span><br><span class="line">            self.n = self.n + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> r</span><br><span class="line">        <span class="keyword">raise</span> StopIteration()</span><br><span class="line">        </span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> Fab(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(n)</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Go-Web</title>
    <url>/2022/07/05/Go-Web/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="? 前言"></a>? 前言</h2><p>最近看了下<code>Go Web编程</code>这本书，再去看了下源码，想对<code>net/http</code>包中的一些关键的函数，接口的定义和关系做一个记录</p>
<h3 id="多路复用器"><a href="#多路复用器" class="headerlink" title="? 多路复用器"></a>? 多路复用器</h3><blockquote>
<p>Go中web应用需要对客户端的请求响应，为了将不同请求URL转发到不同的处理器(Handler)进行处理需要用到多路复用器(ServeMux)</p>
</blockquote>
<ul>
<li><p><code>(var) DefaultServeMux</code>: <code>ListenAndServe(string, Handler) error</code> 中第二个参数的默认值，实质是一个指向<code>ServeMux</code>类型的指针，是<code>ServeMux</code>的一个实例，但<code>ServeMux</code>同时又实现了Handler接口(故可以充当第二个参数的默认值)</p>
<p><strong>源码:</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DefaultServeMux is the default ServeMux used by Serve.</span></span><br><span class="line"><span class="keyword">var</span> DefaultServeMux = &amp;defaultServeMux</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> defaultServeMux ServeMux</span><br></pre></td></tr></table></figure>


</li>
<li><p><code>(func) NewServeMux()</code>: 返回一个<code>ServeMux</code></p>
</li>
<li><p><code>(struct) ServeMux</code>: 多路复用器结构，负责URL的路径和处理的映射，以及通过<code>自身的ServeHTTP</code>方法调用URL映射对应的<code>处理器的ServeHTTP方法</code></p>
<p><strong>源码:</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ServeMux <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu    sync.RWMutex</span><br><span class="line">	m     <span class="keyword">map</span>[<span class="type">string</span>]muxEntry</span><br><span class="line">	es    []muxEntry <span class="comment">// slice of entries sorted from longest to shortest.</span></span><br><span class="line">	hosts <span class="type">bool</span>       <span class="comment">// whether any patterns contain hostnames</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="服务器"><a href="#服务器" class="headerlink" title="?  服务器"></a>?  服务器</h3><blockquote>
<p>负责启动监听和配置服务</p>
<p>如果简单配置可以直接调<code>http.ListenAndServe</code>函数来进行监听，复杂配置则需要构建一个Server结构体来调用其ListenAndServe方法</p>
</blockquote>
<ul>
<li><p><code>(struct) Server</code>: 用于细化配置的结构体</p>
<p><strong>源码:</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">    Addr <span class="type">string</span></span><br><span class="line">    Handler Handler</span><br><span class="line">    </span><br><span class="line">    TLSConfig *tls.Config</span><br><span class="line">    </span><br><span class="line">    ReadTimeout time.Duration</span><br><span class="line">    ReadHeaderTimeout time.Duration</span><br><span class="line">    WriteTimeout time.Duration</span><br><span class="line">    IdleTimeout time.Duration</span><br><span class="line">    </span><br><span class="line">    MaxHeaderBytes <span class="type">int</span></span><br><span class="line">    </span><br><span class="line">    TLSNextProto <span class="keyword">map</span>[<span class="type">string</span>]<span class="function"><span class="keyword">func</span><span class="params">(*Server, *tls.Conn, Handler)</span></span></span><br><span class="line">    </span><br><span class="line">    ConnState <span class="function"><span class="keyword">func</span><span class="params">(net.Conn, ConnState)</span></span></span><br><span class="line">    </span><br><span class="line">    ErrorLog *log.Logger</span><br><span class="line">    </span><br><span class="line">    BaseContext <span class="function"><span class="keyword">func</span><span class="params">(net.Listener)</span></span> context.Context</span><br><span class="line">    ConnContext <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, c net.Conn)</span></span> context.Context</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>(func) ListenAndServe(addr string, handler Handler) error</code>: 开启监听和进行处理，是整个web应用的启动器</p>
</li>
<li><p><code>(func) ListenAndServeTLS(addr, certFile, keyFile string, handler Handler) error</code>: ListenAndServe的https版本</p>
</li>
</ul>
<h3 id="处理器和处理器函数"><a href="#处理器和处理器函数" class="headerlink" title="?  处理器和处理器函数"></a>?  处理器和处理器函数</h3><blockquote>
<p>Go web中实际处理请求的函数或类型</p>
<p>处理器：实现了Handler接口的任意类型，可以是结构体，函数类型等</p>
<p>处理器函数：普通的函数，但是必须要以 <code>http.ResponseWriter</code>和<code>*http.Request</code>为参数</p>
</blockquote>
<ul>
<li><p><code>(interface) Handler &#123;ServeHTTP(ResponseWriter, *Request)&#125;</code>: 处理器接口，实现了该接口的即为处理器</p>
</li>
<li><p><code>(func) http.Handle(pattern string, handler Handler)</code>: 将Handler和DefaultServeMux (或<code>自定义的ServeMux</code>) 绑定，使其处理<code>pattern</code>上的请求。实质是<code>ServeMux</code>的方法，方便调用故在http包中创建。<strong>实质:</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// http.Handle</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handle</span><span class="params">(pattern <span class="type">string</span>, handler Handleer)</span></span> &#123;</span><br><span class="line">    DefaultServeMux.Handle(pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在server.go源码中</span></span><br></pre></td></tr></table></figure>


</li>
<li><p><code>(func) http.HandleFunc(pattern string, handler func(ResponseWriter, *Request))</code>: 将处理器函数与<code>ServeMux</code>绑定并监听<code>pattern</code>路径。实质会被转换为一个<code>Handler</code>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// http.HandleFunc</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="type">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span></span>) &#123;</span><br><span class="line">    DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ServeMux.HandleFunc</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span></span> HandleFunc(pattern <span class="type">string</span>, handler <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span>) &#123;</span><br><span class="line">    mux.Handle(pattern, HandlerFunc(handler))</span><br><span class="line">&#125; <span class="comment">// 通过显式类型转换将底层类型相同的handler转换为HandlerFunc类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HandlerFunc是个函数类型</span></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br><span class="line"><span class="comment">/*并且它实现了Handler接口，也就是说，</span></span><br><span class="line"><span class="comment">HandlerFunc类型是个处理器(Handler),</span></span><br><span class="line"><span class="comment">故调用HandleFunc方法实质是调用Handle方法，</span></span><br><span class="line"><span class="comment">且将一个普通函数类型的参数转换成了一个处理器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f HandlerFunc)</span></span> ServeHTTP(w ResponseWriter, r *Request) &#123;</span><br><span class="line">  f(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>注解和Aop重写bot</title>
    <url>/2022/04/29/Rewrite-Bot-With-Reflection-And-Aop/</url>
    <content><![CDATA[<h2 id="？前言"><a href="#？前言" class="headerlink" title="？前言"></a>？前言</h2><p>之前就有个想法把bot用spring重写一下。了解完一些基础的东西后终于能开写了。</p>
<h2 id="？基于注解加反射"><a href="#？基于注解加反射" class="headerlink" title="？基于注解加反射"></a>？基于注解加反射</h2><h3 id="推"><a href="#推" class="headerlink" title="推"></a>推</h3><p>这一点是看了<a href="https://nuotian.furry.pro/blog/archives/244"><code>诺天的博客</code></a>。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li><ol>
<li>写个自定义注解用以标记方法</li>
</ol>
</li>
<li><ol start="2">
<li><p>利用spring自带的<code>SpringUtil.getApplicationContext().getBeansWithAnnotation(Controller.class)</code>来获取所有被@Controller标记的类的bean。</p>
<p>   【注： 这里的SpringUtil是你自己的写的任意实现了<code>ApplicationContextAware</code>接口的类的名字。并且注解类型必须是Spring里的注解（@Controller,@Component等，不然获取不到bean</p>
</li>
</ol>
</li>
<li><ol start="3">
<li>利用反射的相关方法获取所有方法。再做个遍历筛选出带有自定义注解的方法加入一个列表。</li>
</ol>
</li>
<li><ol start="4">
<li>监听器中调用这个列表进行逻辑判断，确定什么时候调用并传入方法需要的实参</li>
</ol>
</li>
<li><ol start="5">
<li>这样发消息的时候就能实现自动判断并执行</li>
</ol>
</li>
</ul>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>博客里写的已经很详细了。但是总感觉有些功能还可以再补充一下：</p>
<ul>
<li><p>逻辑判断和多种权限：</p>
<p>  一：<a class="link"   href="https://nuotian.furry.pro/blog/" >诺天<i class="fas fa-external-link-alt"></i></a>写的消息的逻辑判断是放在注解中，再和bot接收到的消息进行对比来实现的。但是这样</p>
<p>  逻辑一复杂就会让监听器太冗杂。</p>
<p>  二：一个注解只能让一个方法用于Group或Friend，没法多个权限</p>
<p>  解决方案：</p>
<ul>
<li><p>(一)让注解可重复，增加注解元素</p>
<p>  @Event注解：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Repeatable(Events.class)</span> <span class="comment">// 元注解，使该注解能重复。@Events是含有 返回Event[] 的方法的注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Event</span><br><span class="line">&#123;</span><br><span class="line">    EventEnum <span class="title function_">eventType</span><span class="params">()</span> <span class="keyword">default</span> EventEnum.NONE; <span class="comment">// EventEnum是个枚举类</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">authority</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>; <span class="comment">// 第一层判断,是否开启这个方法</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">judgeByMethod</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>; <span class="comment">// 复杂判断时开启这个</span></span><br><span class="line">    String <span class="title function_">message</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>; <span class="comment">// 第二层判断,触发条件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  @Events注解：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Events</span><br><span class="line">&#123;</span><br><span class="line">    Event[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 注意@Events注解必须写@Target，且元素类型是@Event的子集</p>
</blockquote>
</li>
<li><p>(二)除了message的判断，再在反射时把<code>MessageChain</code>传进去。</p>
<ul>
<li>复杂的方法把<code>judgeByMethod</code>设为true，让方法利用<code>MessageChain</code>获得消息进行逻辑处理</li>
<li>简单的方法把<code>judgeByMethod</code>设为false，利用<code>message</code>注解元素在监听器中进行equals判断</li>
</ul>
</li>
<li><p>结果：利用<code>authority</code>和<code>message</code>来灵活分配权限(虽然也不灵活就是了)；<code>judgeByMethod</code>实现判断权限转移</p>
</li>
</ul>
</li>
</ul>
<h2 id="？基于注解和切面编程-Aop"><a href="#？基于注解和切面编程-Aop" class="headerlink" title="？基于注解和切面编程(Aop)"></a>？基于注解和切面编程(Aop)</h2><p>因为Aop是根据反射开发的，于是我想能不能用Aop写一个。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>利用Aop对被指定注解标记的方法进行增强。在方法执行前进行一个判断。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>Aop部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类上标注<span class="meta">@Aspect</span>注解</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切入点 实际切入的方法</span></span><br><span class="line"><span class="comment">// 注意是对Events切入，因为多个Event注解其实在获取的时候会转换成@Events(&#123;@Event(xx), @Event(xx)&#125;)</span></span><br><span class="line"><span class="meta">@PointCut(&quot;@annotation(com.yanfang.animabotaop.annotations.Events)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">judgeMethodPointCut</span><span class="params">()</span> &#123;&#125; <span class="comment">// 切入方法？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 环绕通知</span></span><br><span class="line"><span class="comment">// &amp;&amp; @annotation(events)是传入参数给通知方法的一种手段，可以省去声明</span></span><br><span class="line"><span class="comment">// around方法参数名要和@Around中一致</span></span><br><span class="line"><span class="comment">// ProceedingJoinPoint 是环绕通知特有的，是JoinPoint的子接口，其他通知为JoinPoint。</span></span><br><span class="line"><span class="comment">// 该参数的功能很强大</span></span><br><span class="line"><span class="meta">@Around(&quot;judgeMethodPointCut() &amp;&amp; @annotation(events)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(<span class="meta">@NotNull</span> ProceedingJoinPoint jpt, <span class="meta">@NotNull</span> Events events)</span> <span class="keyword">throws</span> Throwable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (Event eventAnnotation : events.value())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取实参值（注意是“值”</span></span><br><span class="line">        Object[] argValues = jpt.getArgs();</span><br><span class="line">        <span class="comment">// 获取传入的event，这里默认所有方法第一个参数都是MessageEvent</span></span><br><span class="line">        <span class="type">MessageEvent</span> <span class="variable">event</span> <span class="operator">=</span> (MessageEvent) argValues[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 进行逻辑判断，这里和用反射时一样</span></span><br><span class="line">        <span class="keyword">if</span> (eventAnnotation.authority())</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;已授权&quot;</span>);</span><br><span class="line">                <span class="comment">// 有复杂逻辑就将judgeByMethod设为true， 交给方法进行复杂逻辑处理</span></span><br><span class="line">                <span class="keyword">if</span> (eventAnnotation.judgeByMethod() || (eventAnnotation.message().equals(event.getMessage().contentToString())))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (event.getSubject() <span class="keyword">instanceof</span> Group &amp;&amp; eventAnnotation.eventType() == EventEnum.GROUPEVENT)</span><br><span class="line">                    &#123;</span><br><span class="line">                        joinPoint.proceed(argValues);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (event.getSubject() <span class="keyword">instanceof</span> Friend &amp;&amp; eventAnnotation.eventType() == EventEnum.MASTEREVENT)</span><br><span class="line">                    &#123;</span><br><span class="line">                        joinPoint.proceed(argValues);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (event.getSubject() <span class="keyword">instanceof</span> Member &amp;&amp; eventAnnotation.eventType() == EventEnum.TEMPEVENT)</span><br><span class="line">                    &#123;</span><br><span class="line">                        joinPoint.proceed(argValues);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>监听器方法方面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EventHandler</span></span><br><span class="line"><span class="keyword">public</span> ListeningStatus <span class="title function_">onMessage</span><span class="params">(<span class="meta">@NotNull</span> MessageEvent event)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@NotNull</span> <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> SpringUtil.getBean(Test.class);</span><br><span class="line">    test.test(event);</span><br><span class="line">    <span class="keyword">return</span> ListeningStatus.LISTENING;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Events(@Event(eventType = EventEnum.MASTEREVENT, authority = true, message = &quot;test&quot;))</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(MessageEvent event)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (event == <span class="literal">null</span>) System.out.println(<span class="string">&quot;event 为空&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> event.getSubject().sendMessage(<span class="string">&quot;get&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p>authority为true时发送了get， 为false时没发送get。说明执行了环绕通知</p>
<h3 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h3><ul>
<li>注意Aop和反射不同的一点是：反射可以帮助传入实参；而Aop只能获取方法被传入的实参进行处理，而不能传入参数（毕竟Aop的原衷是不影响方法本身的情况下进行对方法的增强。<ul>
<li>而实参在监听器方法里传入</li>
</ul>
</li>
<li>这里不能通过获取所有Event注解， 再分别进行处理，而需要获取@Events，再通过它的value()元素获取所有的@Event注解 [即使表面上可以在方法上多写几个@Event注解。但实际是<code>@Events(&#123;@Event(...), @Event(...)&#125;)</code>,但是用反射好像可以直接获取多个@Event注解进行遍历处理</li>
<li>注意通知的方法<code>around()</code>传参不能直接传入，而是需要在<code>@Around</code>中传入。否则会<code>报空</code>。（其实是获取方法上的@Events注解，然后传进around()方法</li>
</ul>
<h2 id="？比较与总结"><a href="#？比较与总结" class="headerlink" title="？比较与总结"></a>？比较与总结</h2><p>总的来说，各有优缺。</p>
<ul>
<li><p>反射：先进行判断，然后再根据判断结果来决定是否执行方法</p>
</li>
<li><p>Aop：要先调用方法（注意还并没有实际执行），进而会触发通知，用通知中的方法进行逻辑判断</p>
</li>
<li><p>反射代码较多，但是处理上更灵活，不必先调用方法</p>
</li>
<li><p>Aop要先调用方法，才会触发通知，但是代码量更少，更简洁</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>注解Aopbot</tag>
      </tags>
  </entry>
</search>
